function RenderFun(fid, model, ii, right, aspect, plane, camPosDifference)

% Settings
L = [20,20,20];
ambient = 0.5;
diffuse = 0.7;
phong = 0.0;
phongSize = 25;
% Colours
filColour = [.1 .1 .1];			% Filament spring is black
stickColour = [0.8 .8 0.8];		% Sticking spring is white
anchorColour = [.5 .5 .5];		% Anchoring spring is grey
cellColours = [                 % Bright red, dark blue or light green
    1.0,0.0,0.0;
    0.0,0.0,0.4;
    0.7,1.0,0.7];

minPos = min([model.ballArray.pos],[],2)*1e6;		% *1e6 to convert to POVRay coordinates. 2 is for dimension 2
maxPos = max([model.ballArray.pos],[],2)*1e6;
C = (maxPos+minPos)/2;	% Camera view point is at the plane, right in the middle, height == radius
camView = C;
camPos = C+camPosDifference;

NSave = length(model.ballArray(1).posSave);
if model.relaxationIter==0 && model.growthIter==0
	NSave = 0;
end
if ii~=NSave
	plotIntermediate=true;		% If this is not the first iteration, do the intermediate plotting (i.e. use posSave instead of pos)
else
	plotIntermediate=false;
end

% Build camera stuff
fprintf(fid,'#declare Lx = %f;\n',L(1));
fprintf(fid,'#declare Ly = %f;\n',L(2));
fprintf(fid,'#declare Lz = %f;\n\n',L(3));
fprintf(fid,['camera {\n',...
	'\torthographic\n',...
	sprintf('\tlocation <%g, %g, %g>\n', camPos(1), camPos(2), camPos(3)),...
	sprintf('\tlook_at  <%g, %g, %g>\n', camView(1), camView(2), camView(3)),...
	sprintf('\tright <%g, 0.0, 0.0>\n', right),...
	sprintf('\tup <0.0, %g/%g, 0.0>\n', right, aspect),...
	'}\n\n']);
fprintf(fid,'background { color rgb <1, 1, 1> }\n\n');
fprintf(fid,'light_source { < 0.0,  10*Ly,  0.0> color rgb <1,1,1> }\n');

% Build spheres and rods
for iCell=1:length(model.cellArray)
	cell = model.cellArray(iCell);
	fprintf(fid,['// Cell no. ' num2str(iCell-1) '\n']);		% -1 because we want Java numbering
	% Determine colour for this cell
	ancestor = cell;
	ancestorIndex = iCell-1;
	while ancestorIndex+1>size(cellColours,1) && ~isempty(ancestor.mother)	% Find the oldest ancestor that we can colour
		ancestorIndex = ancestor.mother;
		ancestor = model.cellArray(ancestorIndex+1);
	end
	if length(unique([model.cellArray.type]))==1 && model.attachmentRate == 0;		% Colour by generation
		if model.NCellInit>size(cellColours,1)
			colour = cellColours(1,:);
		else
			colour = cellColours(ancestorIndex+1,:);
		end
	else														% Colour by type, because we don't have enough colours
		if ancestor.born ~= 0 && isempty(ancestor.mother)       % This is an attached cell
			colour = cellColours(end,:);
		else
			colour = cellColours(ancestor.type==unique([model.cellArray.type]),:);
		end
	end
	if cell.type<2
		% Spherical cell
		ball = model.ballArray(cell.ballArray(1)+1);			% +1 because of Java --> MATLAB

		if plotIntermediate
			pos = ball.posSave(ii+1,:)*1e6;
		else
			pos = ball.pos*1e6;
		end
		position = sprintf('\t < %10.6f,%10.6f,%10.6f > \n', pos(1), pos(2), pos(3));
		fprintf(fid,['sphere\n',...
			'{\n',...
			position,...
			sprintf('\t%10.6f\n', ball.radius*1e6),...
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', colour(1), colour(2), colour(3)),...
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			['\t\t\tphong ' num2str(phong) '\n'],...
			['\t\t\tphong_size ' num2str(phongSize) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n\n']);
	elseif cell.type>1	% Rod
		ball = model.ballArray(cell.ballArray(1)+1);				% +1 because of Java --> MATLAB
		ballNext = model.ballArray(cell.ballArray(2)+1);

		if plotIntermediate
			position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.posSave(ii+1,1)*1e6, ball.posSave(ii+1,2)*1e6, ball.posSave(ii+1,3)*1e6),...		% +1 because of Java --> MATLAB
				sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.posSave(ii+1,1)*1e6, ballNext.posSave(ii+1,2)*1e6, ballNext.posSave(ii+1,3)*1e6)];

			position2 = sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ball.posSave(ii+1,1)*1e6, ball.posSave(ii+1,2)*1e6, ball.posSave(ii+1,3)*1e6);

			position3 = sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ballNext.posSave(ii+1,1)*1e6, ballNext.posSave(ii+1,2)*1e6, ballNext.posSave(ii+1,3)*1e6);
		else
			position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.pos(1)*1e6, ball.pos(2)*1e6, ball.pos(3)*1e6),...
				sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.pos(1)*1e6, ballNext.pos(2)*1e6, ballNext.pos(3)*1e6)];

			position2 = sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ball.pos(1)*1e6, ball.pos(2)*1e6, ball.pos(3)*1e6);

			position3 = sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ballNext.pos(1)*1e6, ballNext.pos(2)*1e6, ballNext.pos(3)*1e6);
		end
		fprintf(fid,['cylinder\n',...		% Sphere-sphere connection
			'{\n',...
			position,...
			sprintf('\t%10.6f\n', ball.radius*1e6),...
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', colour(1), colour(2), colour(3)),...
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			['\t\t\tphong ' num2str(phong) '\n'],...
			['\t\t\tphong_size ' num2str(phongSize) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n',...
			'sphere\n',...			% First sphere
			'{\n',...
			position2,...
			sprintf('\t%10.6f\n', ball.radius*1e6),...
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', colour(1), colour(2), colour(3)),...
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			['\t\t\tphong ' num2str(phong) '\n'],...
			['\t\t\tphong_size ' num2str(phongSize) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n',...
			'sphere\n',...			% Second sphere
			'{\n',...
			position3,...
			sprintf('\t%10.6f\n', ballNext.radius*1e6),...
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', colour(1), colour(2), colour(3)),...
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			['\t\t\tphong ' num2str(phong) '\n'],...
			['\t\t\tphong_size ' num2str(phongSize) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n\n']);
	end
end

% Build filament springs
for iFil = 1:length(model.filSpringArray)
	fil = model.filSpringArray(iFil);
	if fil.type==3 || fil.type==4                   % sphere's fil spring or rod's short fil spring
		fprintf(fid,['// Filament spring no. ' num2str(iFil-1) '\n']);
		ball 	= model.ballArray(fil.ballArray(1)+1);
		ballNext = model.ballArray(fil.ballArray(2)+1);

		if plotIntermediate
			position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.posSave(ii+1,1)*1e6, ball.posSave(ii+1,2)*1e6, ball.posSave(ii+1,3)*1e6),...
				sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.posSave(ii+1,1)*1e6, ballNext.posSave(ii+1,2)*1e6, ballNext.posSave(ii+1,3)*1e6)];
		else
			position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.pos(1)*1e6, ball.pos(2)*1e6, ball.pos(3)*1e6),...
				sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.pos(1)*1e6, ballNext.pos(2)*1e6, ballNext.pos(3)*1e6)];
		end
		fprintf(fid,['cylinder\n',...
			'{\n',...
			position,...
			sprintf('\t%10.6f\n', ball.radius*1e5),...
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', filColour(1), filColour(2), filColour(3)),...
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n\n']);
	end
end

% Build stick spring array
for iStick = 1:length(model.stickSpringArray)
	fprintf(fid,['// Sticking spring no. ' num2str(iStick-1) '\n']);
	spring = model.stickSpringArray(iStick);
	ball = model.ballArray(spring.ballArray(1)+1);
	ballNext = model.ballArray(spring.ballArray(2)+1);

	if plotIntermediate
		position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.posSave(ii+1,1)*1e6, ball.posSave(ii+1,2)*1e6, ball.posSave(ii+1,3)*1e6),...
			sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.posSave(ii+1,1)*1e6, ballNext.posSave(ii+1,2)*1e6, ballNext.posSave(ii+1,3)*1e6)];
	else
		position = [sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ball.pos(1)*1e6, ball.pos(2)*1e6, ball.pos(3)*1e6),...
			sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', ballNext.pos(1)*1e6, ballNext.pos(2)*1e6, ballNext.pos(3)*1e6)];
	end
	fprintf(fid,['cylinder\n',...
		'{\n',...
		position,...
		sprintf('\t%10.6f\n', ball.radius*1e5),...									% 1e5 == 1/10 of the actual ball radius
		'\ttexture{\n',...
		'\t\tpigment{\n',...
		sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n',stickColour(1), stickColour(2), stickColour(3)),...
		'\t\t}\n',...
		'\t\tfinish{\n',...
		['\t\t\tambient ' num2str(ambient) '\n'],...
		['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
		'\t\t}\n',...
		'\t}\n',...
		'}\n\n']);
end

%Build anchor spring array
for iAnchor = 1:length(model.anchorSpringArray)
	fprintf(fid,['// Anchor spring no. ' num2str(iAnchor-1) '\n']);					% -1 so we use Java numbering to display this
	spring = model.anchorSpringArray(iAnchor);

	ball = model.ballArray(spring.ballArray(1)+1);
	if plotIntermediate
		position= sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ball.posSave(ii+1,1)*1e6, ball.posSave(ii+1,2)*1e6, ball.posSave(ii+1,3)*1e6);
	else
		position= sprintf('\t < %10.6f,%10.6f,%10.6f > \n', ball.pos(1)*1e6, ball.pos(2)*1e6, ball.pos(3)*1e6);
	end
	if ~all(round(spring.anchorPoint*1e6/1000)*1000==round(ball.pos*1e6/1000)*1000)	% If equal until 3 decimals, scaled to micron, skip this one because it will produce "degenerate cylinders"
		fprintf(fid,['cylinder\n',...
			'{\n',...
			position,...
			sprintf('\t<%10.6f,%10.6f,%10.6f>,\n', spring.anchorPoint(1)*1e6, spring.anchorPoint(2)*1e6, spring.anchorPoint(3)*1e6),...
			sprintf('\t%10.6f\n', ball.radius*1e5),...	% 1e5 because it is a spring
			'\ttexture{\n',...
			'\t\tpigment{\n',...
			sprintf('\t\t\tcolor rgb<%10.6f,%10.6f,%10.6f>\n', anchorColour(1), anchorColour(2), anchorColour(3)),...		%Anchoring springs are yellow
			'\t\t}\n',...
			'\t\tfinish{\n',...
			['\t\t\tambient ' num2str(ambient) '\n'],...
			['\t\t\tdiffuse ' num2str(diffuse) '\n'],...
			'\t\t}\n',...
			'\t}\n',...
			'}\n\n']);
	end
end

% Create plane
if plane
	if model.normalForce
		yPlane = 0;
	else
		yPlane = minPos(2)-5.0;
		yPlane = round(yPlane);																				% Solution for weird solid black plane showing up for some yPlane values
	end
	fprintf(fid,['union {\n',...
		'\tbox {\n',...
		'\t\t<' num2str(minPos(1)-25) ', ' num2str(yPlane) ', ' num2str(minPos(3)-25) '>\n',...				% Corner 1. Centred around 0.5 Lx and 0.5 Lz
		'\t\t<' num2str(maxPos(1)+25) ', ' num2str(yPlane) ', ' num2str(maxPos(3)+25) '>\n',...				% Corner 2
		'\t\trotate<0.0, 45, 0.0>\n',...
		'\t\ttexture {\n',...
		'\t\t\tpigment {\n',...
		'\t\t\t\tbrick\n',...
		'\t\t\t\tcolor rgb<0, 0, 0>\n',...
		'\t\t\t\tcolor rgb<1, 1, 1>\n',...
		'\t\t\t\tbrick_size<1.0, 1.0, 1.0>\n',...
		'\t\t\t\tmortar 0.025\n',...
		'\t\t\t\ttranslate<0.0 0.0 0.5>\n',...
		'\t\t\t\trotate<0.0 45 0.0>\n',...
		'\t\t\t}\n',...
		'\t\t\tfinish {\n',...
		['\t\t\t\tambient ' num2str(ambient) '\n'],...
		['\t\t\t\tdiffuse ' num2str(diffuse) '\n'],...
		'\t\t\t}\n',...
		'\t\t}\n',...
		'\t}\n',...
		'}\n']);
end